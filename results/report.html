<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kaeya Mehta, Priyanka Durai, Soome Pyo, Taneesha Panda, Naira Younas, Alex Dieter">
<meta name="dcterms.date" content="2025-11-05">

<title>Biomarkers of ASD</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="report_files/libs/clipboard/clipboard.min.js"></script>
<script src="report_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="report_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="report_files/libs/quarto-html/popper.min.js"></script>
<script src="report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="report_files/libs/quarto-html/anchor.min.js"></script>
<link href="report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="report_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="report_files/libs/bootstrap/bootstrap-16bbabe37efa2ecafad14e96199f1a13.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Biomarkers of ASD</h1>
<p class="subtitle lead">Module 1 - Table 1</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Kaeya Mehta, Priyanka Durai, Soome Pyo, Taneesha Panda, Naira Younas, Alex Dieter </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Updated</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 5, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="abstract" class="level2">
<h2 class="anchored" data-anchor-id="abstract">Abstract</h2>
<p>In this report, we analyze methods used to identify protein biomarkers for autism spectrum disorder (ASD) in children. To obtain the data blood samples were collected from 76 boys with ASD and 78 typically developing (TD) boys, as well as several additional characteristics. The baseline, in-class analysis for this data involved selecting 10 significant proteins from multiple t-testing, selecting another 10 significant proteins from random forest, and finally, intersecting the two panels and fitting a logistic regression model, used to create a classifier (that classified children as having ASD or being TD). We used a log transformation on our raw data, which provided a more Gaussian spread and minimized the impact of outliers (which is why the technique was used for the cleaned dataset we worked with). We used three methodologies that varied from the one done in our class. We split our data into training and testing sets prior to analysis, we increased our initial significant protein panel from ten to fifteen, and we used a fuzzy intersection, rather than a hard intersection, for the final protein panel used for a logistic regression. These three methods allowed us to have increased specificity in comparison to the baseline in-class analysis. We obtained our highest performing classifier from running the baseline in-class analysis code to the end of the logistic regression, and then viewing a summary of the glm() function. From observing p-values, we removed two proteins and the intercept from our panel, and fitted the logistic regression again. From that, we obtained a classifier that outperformed the in-class analysis. The panel consisted of proteins Derm, RELT, and IgD.</p>
</section>
<section id="dataset" class="level2">
<h2 class="anchored" data-anchor-id="dataset">Dataset</h2>
<p>The data for this week’s module come from the paper, Blood biomarker discovery for autism spectrum disorder: A proteomic analysis (Hewitson et al., 2021). This study investigated autism spectrum disorder (ASD) and aimed to identify a panel of proteins that could serve as biomarkers for ASD risk. Blood samples were collected from 76 boys with ASD and 78 typically developing (TD) boys, with ages spanning 18-months to 8 years. The mean age of the ASD participants was 5.6 years, and the mean age of TD participants was 5.7 years. Additional characteristics were recorded, including ethnicity of the participants, presence of co-morbid conditions, and use of prescription medications. For the ASD group, each participant was given an Autism Diagnostic Observation Schedule (ADOS) total score, which provided a continuous measure of overall ASD symptom severity.</p>
<p>In order to quantify protein abundance in the blood samples, a proteomic analysis of serums was performed using SomaLogic’s SOMAScanTM assay 1.3K platform, and a total of 1,317 proteins were measured. After quality control procedures, 192 proteins that did not meet reliability standards were excluded, leaving 1,125 proteins for analysis. The protein abundance data were normalized by first applying a log10 transformation and then a z-transformation. To deal with outliers, any z-transformed values less than -3 and greater than 3 were clipped to -3 and 3, respectively.</p>
</section>
<section id="summary-of-published-analysis" class="level2">
<h2 class="anchored" data-anchor-id="summary-of-published-analysis">Summary of published analysis</h2>
<p><img src="images/flowchart.png" class="img-fluid" width="345"></p>
</section>
<section id="findings" class="level2">
<h2 class="anchored" data-anchor-id="findings">Findings</h2>
<section id="impact-of-preprocessing-and-outliers" class="level3">
<h3 class="anchored" data-anchor-id="impact-of-preprocessing-and-outliers">Impact of preprocessing and outliers</h3>
<p>First we examined the effect of applying a log transformation to the raw protein data. To visualize why this transformation was useful, we created barplots (using the raw data) of the four proteins: CEBPB, CHIP, NSE, and PIAS4. In the plots, the x axis represents the number of proteins found in each subject, and the y axis shows the frequency of subjects with that count.</p>
<p>Before the log transformation, the distributions were right skewed, which means that a couple subjects had very high protein levels, causing the mean to exceed the median. After applying the log transformation, the distribution becomes more centered and approximately normal. This normalization helps de-influence the extreme outliers, allowing for better statistical analysis.&nbsp;</p>
<p><img src="images/q1nottransformed.png" class="img-fluid" width="511"></p>
<p><img src="images/q1nottransformed.png" class="img-fluid" width="511"></p>
<p><img src="images/q1transformed.png" class="img-fluid" width="507"></p>
<p>Second we analyzed the outliers in the dataset. Outliers were identified by protein measurements having an absolute z-score greater than three, representing values more than three standard deviations away from the mean. We identified the outliers per subject by tabulating the number of protein outliers for each individual. Some subjects had quite high numbers of outliers (up to 157), while the mean number of outliers per subject was 15.45 and the median was 8.5. This indicates that while most subjects had a small number of outliers, a few had very high counts.</p>
<p>We also compared outliers across the two groups: ASD and TD. As shown in the boxplot below, the ASD group had fewer outliers than the TD group. Additionally, both the mean and third quartile for the ASD group were smaller than the TD group, suggesting less variability and fewer extremes in the ASD group.</p>
<p><img src="images/q2boxplot.png" class="img-fluid" width="644"></p>
</section>
<section id="methodological-variations" class="level3">
<h3 class="anchored" data-anchor-id="methodological-variations">Methodological variations</h3>
<p>We built upon Hewitson et al.&nbsp;(2021) process to find a panel of proteins that would help early detection of autism spectrum disorder (ASD). To find a panel of proteins we used a couple statistical approaches: a two-sample t-tests to find proteins that differed the most between ASD and TD groups and a Random Forest classifier to rank proteins based on how much they contributed to classification accuracy. We then combined the top results from each method using a hard intersection. Using the overlapping proteins, we built a logistic regression model on the training data and evaluated it on the held-out test set. Using this baseline process, we examined three methodological variations: changing the training/testing split to 70/30, increasing the size of the protein panel, and using a fuzzy intersection instead of a hard intersection. The results are explained below.</p>
<p>For our first methodological variation, we partitioned our data into testing and training subsets before conducting any testing. We randomly selected 70% of the data for training, and set aside 30% for testing. Then, we proceeded to conduct our multiple testing, random forest, and logistic regression just as the in-class analysis. In short, we selected the 10 most significant proteins from multiple testing, and random forest. Then, we intersected the two protein panels to determine the proteins that were deemed significant by both tests. Based on that, we fit a logistic regression model on the training set, and then tested the model on our training set. We obtained a model with parameters Calcineurin, MAPK2, MAPK14, IGFBP-1, ALCAM and Notch 1, with sensitivity = 0.56,&nbsp; specificity = 0.591, accuracy = 0.574 and roc_auc = 0.649. The significant predictors and the final panel from the model are MAPK2, IGFBP-1, and ALCAM.</p>
<p>For our second methodological variation, we used the same procedure as method 1, but we selected initial panels of size 15 from our multiple testing and random forest analysis. After logistic regression, we obtained a model with the predictors Calcineurin, MAPK2, MAPK14, IGFBP-1, ALCAM, Notch 1, MMP-2, PERL and Coagulation Factor IX. We obtained metrics of sensitivity = 0.56, specificity = 0.682, accuracy = 0.617 and roc_auc - 0.635. The significant predictors and the final panel from the model are MAPK2, IGFBP-1, ALCAM, and Notch 1.&nbsp;</p>
<p>For our last methodological variation, we used the same procedure as method 1 (partitioning 70/30, and n = 10). After conducting our multiple testing and random forest analysis, we used a fuzzy intersection of the panels we obtained from that test to use for our logistic regression model. We obtained a model with the predictors RELT, CXCL16, soluble, DERM, MRC2, C1QR1, ILT-4, OMD, RET, MAPK2, TSP4, TGF-b R III, PIK3CA/PIK3R1, Nectin-like protein 2, SOST and DKK3. After testing, we obtained metrics of sensitivity = 0.64, specificity = 0.682, accuracy = 0.660 and roc_auc = 0.715. The significant predictors and final panel from the model are MAPK2, Notch 1, and IgD.</p>
<p>All three of our methods had lower accuracy and sensitivity scores than the original, in-class analysis script (it had an accuracy of 0.71 and a sensitivity of 0.833). However, methods one and two had improved specificity (the in-class analysis had a specificity of 0.538).&nbsp;</p>
<p>When comparing the results of the three varying techniques, it seems as though sensitivity and roc_auc improved with the fuzzy intersection. Our second method had the highest specificity score.</p>
</section>
<section id="improved-classifier" class="level3">
<h3 class="anchored" data-anchor-id="improved-classifier">Improved classifier</h3>
<p>When we ran the in class analysis, we got a sensitivity rate of 81.2%, a specificity rate of 73.3%, an accuracy rate of 77.4 % and a roc_auc rate of 88.3%. Our core panel consisted of proteins DERM, RELT, MRC2, IgD, Cadherin-5. Upon viewing the summary of our logistic regression model, we find that the p-value for Cadherin-5 is .83935, suggesting that Cadherin-5 may not be a significant protein. Additionally, the MRC2 protein has a p value of .56855, so it may not be significant. Finally, we see that the intercept’s p value is 0.64288. Therefore, we dropped these 3 predictors. After dropping these 2 proteins and the intercept, our model had a sensitivity rate of 93.8%, specificity rate of 73.3%, accuracy rate of 83.9%, and roc_auc rate of 88.3%. Therefore, we have found a simpler panel consisting of Derm, RELT, and IgD only that outperforms the inclass model.&nbsp;</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>